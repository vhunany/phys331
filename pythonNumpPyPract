{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "4eafac1a",
   "metadata": {},
   "source": [
    "### Studio 1\n",
    "## Put your group number and the names of you and your groupmates here:\n",
    "### Group: 9\n",
    "- 1 -- Viktorya Hunanyan\n",
    "- 2 -- Victor Nguyen\n",
    "- 3 -- Hannah James\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "554cfb20",
   "metadata": {},
   "source": [
    "\n",
    "## Getting Comfortable with Python and NumPy\n",
    "\n",
    "The goal of this studio is for you to get some practical experience manipulating basic python and NumPy data structures such as numbers, strings, and NumPy arrays.  In particular we're going to work on "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 241,
   "id": "6888f914",
   "metadata": {},
   "outputs": [],
   "source": [
    "## run this cell first to import all the necessary tools\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5c1fa4c2",
   "metadata": {},
   "source": [
    "# Problem 1\n",
    "## Masking in Python\n",
    "### Part A)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8d20b4a3",
   "metadata": {},
   "source": [
    "Write a function `maskn(lst, i)` in the cell below which accepts a list of integers `lst` and a single integer *i*, and returns a list called mask, of the same length as `lst`, where the elements of mask are `0` for each number (in the original list) not divisible by `i`, and `1` for each number that is. The function should work for a list of any length."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b80f1b82",
   "metadata": {},
   "source": [
    "This function should **only use built-in Python functions** (lists, `for` loops, functions, etc.).  No NumPy (yet)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 245,
   "id": "be140b6a",
   "metadata": {},
   "outputs": [],
   "source": [
    "def maskn(lst: list[int], i: int):\n",
    "    '''\n",
    "    Generates a mask which determines whether the elements of a list are divisible by an integer i.\n",
    "    \n",
    "    Note this should only be done with Python lists!\n",
    "    \n",
    "    PARAMETERS:\n",
    "        lst - A Python list of integers.\n",
    "        i   - An integer.\n",
    "    \n",
    "    RETURN VALUE:\n",
    "        A Python list of integers which is either 0 or 1; a\n",
    "        value of 1 indicates that the corresponding element of\n",
    "        the list is divisible by i, 0 indicates otherwise.\n",
    "    '''\n",
    "    mask: list[int] = []\n",
    "    \n",
    "    for elem in lst: \n",
    "        if elem % i == 0:\n",
    "            mask.append(0)\n",
    "        else: \n",
    "            mask.append(1)\n",
    "        \n",
    "    # ??? Put your solution here ???\n",
    "    return mask"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ce7154ad",
   "metadata": {},
   "source": [
    "### Part B)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "333da937",
   "metadata": {},
   "source": [
    "Now do the same thing in the function `maskn_array(ary, i)`, but using NumPy arrays instead of Python lists. Your new function should return a NumPy array of Booleans that is False for each number in ary not divisible by `i`, and True for each number that is. See if you can write the code for the function in one line!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 248,
   "id": "5d42bb78",
   "metadata": {},
   "outputs": [],
   "source": [
    "def maskn_array(ary: np.ndarray, i):\n",
    "    '''\n",
    "    Generates a mask which determines whether the elements of a NumPy array are divisible by an integer i.\n",
    "    \n",
    "    Note this should only be done with NumPy arrays!  See if you can write the function in one line!\n",
    "    \n",
    "    PARAMETERS:    \n",
    "        ary - A NumPy array of integers.\n",
    "        i   - An integer.\n",
    "        \n",
    "    RETURN VALUE:\n",
    "        A NumPy array of booleans which are either True or False\n",
    "    '''\n",
    "\n",
    "    mask_numpy: np.ndarray = np.array(ary % i == 0)\n",
    "\n",
    "    # ??? A solution is required here ???\n",
    "    return mask_numpy"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "18ddc538",
   "metadata": {},
   "source": [
    "### Part C)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bffbe239",
   "metadata": {},
   "source": [
    "Which one do you expect to be faster? Try using the `%%timeit` command from class on both functions (pick a suitable test case, such as a list/NumPy array of integers from 0 to 10,000). Does the timing match your expectations?"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a823925e",
   "metadata": {},
   "source": [
    "#### Timing for maskn function:\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 252,
   "id": "9e0e29e8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "564 μs ± 1.87 μs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "\n",
    "my_list: list[int] = list(range(0, 10001))\n",
    "\n",
    "my_int: int = 2\n",
    "maskn(my_list, my_int)\n",
    "\n",
    "# ??? A solution is required here ???\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c1a3b1ef",
   "metadata": {},
   "source": [
    "#### Timing for maskn_array function:\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 254,
   "id": "b74e8c13",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "32.5 μs ± 11.7 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "my_numpy_array: np.ndarray = np.arange(0, 10000)\n",
    "my_int: int = 2\n",
    "maskn_array(my_numpy_array, my_int)\n",
    "\n",
    "# ??? A solution is required here ???\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fa7cd663",
   "metadata": {},
   "source": [
    "#### Text Response:"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4e7e4bb5",
   "metadata": {},
   "source": [
    "Timing for maskn function: 607 μs ± 14.9 μs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\n",
    "\n",
    "Timing for maskn_array function: 32.6 μs ± 106 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n",
    "\n",
    "The timeing does match our expecatations becuase as we learned numpy is C under the hood. "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "936021e9",
   "metadata": {},
   "source": [
    "# Problem 2\n",
    "## Plotting Piece-wise functions "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "42ef3c64",
   "metadata": {},
   "source": [
    "At the end of Lecture 3, I showed how you can create piece-wise functions in Python using *if/elif/else* statements.  A copy of the function is provided below:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 259,
   "id": "4de991b0",
   "metadata": {},
   "outputs": [],
   "source": [
    "def more_complicated_function(x):  \n",
    "    '''\n",
    "    The piece-wise function from Lecture 3\n",
    "\n",
    "    PARAMETERS:\n",
    "        x - a single input number\n",
    "        \n",
    "    RETURN VALUE:\n",
    "        a single real number\n",
    "    '''\n",
    "\n",
    "    if x < 1:\n",
    "        result =  np.exp(x)\n",
    "    \n",
    "    elif x > 2 and x < 4:\n",
    "        result = -np.cos(x)\n",
    "    \n",
    "    elif x > 4 and x < 5:\n",
    "        result = 1/x**2\n",
    "    \n",
    "    else: \n",
    "        result = 0\n",
    "        \n",
    "    return result"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2b368645",
   "metadata": {},
   "source": [
    "### Part A)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "783a13ba",
   "metadata": {},
   "source": [
    "Using **only Python functions**, evaluate this function on a grid of 1000 points in the domain `[0,6]`.  Note that I did this in the iPython notebook for Lecture 3 (available on Canvas), so you can look that up if you need a hint.  Call the lists `xs_python` and `ys_python` (you don't need to do anything with them yet), but leave a `%%timeit` command in the cell to time how long it takes to generate them."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 262,
   "id": "57839dc2",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "496 μs ± 332 ns per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "\n",
    "xs_python: list[float] = []  # instantiate an empty list, we will build this \n",
    "ys_python: list[float] = []  # instantiate an empty list, we will build this\n",
    "\n",
    "\n",
    "# Define the number of points\n",
    "num_points = 1000\n",
    "\n",
    "# Define the start and end of the interval\n",
    "start = 0.0\n",
    "end = 6.0\n",
    "\n",
    "# Calculate the spacing between points\n",
    "step = (end - start) / (num_points - 1)\n",
    "\n",
    "# Generate the list of points\n",
    "for i in range(0, num_points): \n",
    "    xs_python.append(start + i * step)  # multiply each num 0 - 1000 (not including 1000) by step to get the x values (similar to x*dx) and add it to our list of x's\n",
    "\n",
    "for x in xs_python: # iterate through each elem of the the list \n",
    "    ys_python.append(more_complicated_function(x)) # give a y value for each x in our array and append that to the our empty y list\n",
    "    \n",
    "    # each y-value at an index couples corresponds the the y-value recieved when evaluating it in the x at the same index"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7be9c4bf",
   "metadata": {},
   "source": [
    "### Part B)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b9c652d3",
   "metadata": {},
   "source": [
    "Now we're going to do the same thing, but with **NumPy arrays**.  The tricky part here is that you can do the if statements entirely with boolean operators (`<`,`>=`,`==`, etc.), but they have to be between **NumPy arrays**."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 265,
   "id": "3465d6c3",
   "metadata": {},
   "outputs": [],
   "source": [
    "def more_complicated_function_numpy(input_array):   \n",
    "    '''\n",
    "    Implements the \"more_complicated_function\" from above, but using NumPy arrays\n",
    "    \n",
    "    Note this should only be done with NumPy arrays!  Each if/elif/else statement should be rewritten\n",
    "    as a operation between NumPy arrays.\n",
    "    \n",
    "    PARAMETERS:\n",
    "        input_array - A NumPy array (the xs).\n",
    "        \n",
    "    RETURN VALUE:\n",
    "        A NumPy array of real numbers (the ys)\n",
    "    '''\n",
    "    \n",
    "    ## First I use a built-in numpy function (zeros_like), that creates an array the same \n",
    "    ##shape as input_array, but where every element is zero\n",
    "    output_array = np.zeros_like(input_array)\n",
    "    \n",
    "    ## For the first \"if\" statement, I *mask* every element in input_array larger than one\n",
    "    mask_1 = (input_array < 1)\n",
    "\n",
    "    ## Then, I only calculate the exponential function for the elements in my input_array, but\n",
    "    ## ONLY for the elements where mask_1 is true (i.e. where the corresponding element in \n",
    "    ## input_array is less than one).  Note I need to do this for both the input_array and output_array\n",
    "    output_array[mask_1] = np.exp(input_array[mask_1])\n",
    "    \n",
    "    ## Now do the same thing for the next conditional statements below\n",
    "    mask_2 = (input_array > 2) & (input_array < 4)\n",
    "    output_array[mask_2] = -np.cos(input_array[mask_2])\n",
    "\n",
    "    mask_3 = (input_array > 4) & (input_array < 5)\n",
    "    output_array[mask_3] = 1/((input_array[mask_3])**2)\n",
    "    \n",
    "    return output_array"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0e3d5e2f",
   "metadata": {},
   "source": [
    "Once you've created your function, run the cell below and compare how long it takes to generate the same data as you did in **Part A**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 267,
   "id": "2f2c7ef8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "30.9 μs ± 127 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "\n",
    "xs_numpy = np.linspace(0,6,1000)\n",
    "ys_numpy = more_complicated_function_numpy(xs_numpy)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f0629421",
   "metadata": {},
   "source": [
    "### Part C)\n",
    "As a final check, let's plot the results!  Using the code below, create a plot with two lines on it, one made from (`xs_python`,`ys_python`), and one made from (`xs_numpy`,`ys_numpy`).  They should lie on top of one another, so think about how you can modify the code to show both lines simultainously.\n",
    "\n",
    "Hint: Try reading through the help documentation for the `plt.plot` function below (that you get from hitting Shift-Tab), and see if you can change the style or the size of one of the lines. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 269,
   "id": "af7e15b0",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Text(0, 0.5, 'f(x)')"
      ]
     },
     "execution_count": 269,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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yO1284tf/AK32211lKin16rn9Fr1nF6r3tHr1XN6rXouGl6rATehWERERGKbem5EREQkpqi4ERERkZii4kZERERiioobERERiSkqbsLkkUceoaSkBI/Hw9SpU3n77betjhSV1q5dyxVXXEF+fj6GYfDSSy9ZHSlqLV68mOnTp5OUlER2djbz5s1j586dVseKSkuXLmXChAkdi4bNmDGD1157zepY/cLixYsxDINbb73V6ihR56677sIwjE6X3Nxcq2NFrfLycr73ve+RkZFBfHw8kyZNYsOGDZZkUXETBs8//zy33norP/vZz9i4cSOzZs1i7ty5lJaWWh0t6jQ1NTFx4kQefvhhq6NEvTVr1nDjjTfy/vvvs2rVKgKBAHPmzKGpqcnqaFGnoKCAX//616xfv57169dz0UUX8Y1vfIOtW7daHS2qffTRRyxbtowJEyZYHSVqjR07loqKio7Lli1brI4UlWprazn33HNxOp289tprbNu2jQceeIDU1FRL8uhU8DA4++yzmTJlCkuXLu24bfTo0cybN4/FixdbmCy6GYbBiy++yLx586yO0i8cOXKE7Oxs1qxZw+zZs62OE/XS09P57W9/yw9/+EOro0SlxsZGpkyZwiOPPMI999zDpEmTWLJkidWxospdd93FSy+9xKZNm6yOEvV++tOf8u6770bNqIV6bs6Qz+djw4YNzJkzp9Ptc+bM4b333rMolcSi+vp6oP2gLV0LBoM899xzNDU1MWPGDKvjRK0bb7yRr371q1xyySVWR4lqu3fvJj8/n5KSEr797W+zd+9eqyNFpZdffplp06bxrW99i+zsbCZPnswf//hHy/KouDlD1dXVBINBcnJyOt2ek5NDZWWlRakk1pimycKFCznvvPMYN26c1XGi0pYtW0hMTMTtdrNgwQJefPFFxowZY3WsqPTcc8/x8ccfq2e5G2effTZPPvkkr7/+On/84x+prKxk5syZ1NTUWB0t6uzdu5elS5cyfPhwXn/9dRYsWMAtt9zCk08+aUmeAbcreKQYhtHpummaJ9wmcrpuuukmPvnkE9555x2ro0StkSNHsmnTJurq6lixYgXXXnsta9asUYHzJWVlZfzkJz/hjTfewOPxWB0nqs2dO7fj/8ePH8+MGTMYOnQof/rTn1i4cKGFyaJPKBRi2rRp3HvvvQBMnjyZrVu3snTpUq655po+z6OemzOUmZmJ3W4/oZemqqrqhN4ckdNx88038/LLL/PWW29RUFBgdZyo5XK5GDZsGNOmTWPx4sVMnDiR//t//6/VsaLOhg0bqKqqYurUqTgcDhwOB2vWrOGhhx7C4XAQDAatjhi1EhISGD9+PLt377Y6StTJy8s74YvE6NGjLTuxRsXNGXK5XEydOpVVq1Z1un3VqlXMnDnTolQSC0zT5KabbuKFF17gf/7nfygpKbE6Ur9imiZtbW1Wx4g6F198MVu2bGHTpk0dl2nTpvHd736XTZs2YbfbrY4Ytdra2ti+fTt5eXlWR4k655577glLVezatYvBgwdbkkfDUmGwcOFCvv/97zNt2jRmzJjBsmXLKC0tZcGCBVZHizqNjY3s2bOn4/q+ffvYtGkT6enpFBUVWZgs+tx4440888wz/PWvfyUpKamjdzAlJYW4uDiL00WXO++8k7lz51JYWEhDQwPPPfccq1ev5u9//7vV0aJOUlLSCfO2EhISyMjI0HyuL7n99tu54oorKCoqoqqqinvuuQev18u1115rdbSoc9tttzFz5kzuvfderrrqKj788EOWLVvGsmXLrAlkSlj84Q9/MAcPHmy6XC5zypQp5po1a6yOFJXeeustEzjhcu2111odLeqc7HUCzOXLl1sdLepcd911HX9/WVlZ5sUXX2y+8cYbVsfqN84//3zzJz/5idUxos7VV19t5uXlmU6n08zPzzevvPJKc+vWrVbHilp/+9vfzHHjxplut9scNWqUuWzZMsuyaJ0bERERiSmacyMiIiIxRcWNiIiIxBQVNyIiIhJTVNyIiIhITFFxIyIiIjFFxY2IiIjEFBU3IiIiElNU3IiIiEhMUXEjIiIiMUXFjYiIiMQUFTciIiISU1TciEi/d+TIEXJzc7n33ns7bvvggw9wuVy88cYbFiYTESto40wRiQmvvvoq8+bN47333mPUqFFMnjyZr371qyxZssTqaCLSx1TciEjMuPHGG/nHP/7B9OnT2bx5Mx999BEej8fqWCLSx1TciEjMaGlpYdy4cZSVlbF+/XomTJhgdSQRsYDm3IhIzNi7dy+HDh0iFApx4MABq+OIiEXUcyMiMcHn83HWWWcxadIkRo0axe9+9zu2bNlCTk6O1dFEpI+puBGRmPDv//7v/OUvf2Hz5s0kJiZy4YUXkpSUxCuvvGJ1NBHpYxqWEpF+b/Xq1SxZsoSnnnqK5ORkbDYbTz31FO+88w5Lly61Op6I9DH13IiIiEhMUc+NiIiIxBQVNyIiIhJTVNyIiIhITFFxIyIiIjFFxY2IiIjEFBU3IiIiElNU3IiIiEhMUXEjIiIiMUXFjYiIiMQUFTciIiISU1TciIiISEz5/wF12rV3hDR3JQAAAABJRU5ErkJggg==",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "xs_numpy = np.linspace(0,6,1000)\n",
    "ys_numpy = more_complicated_function_numpy(xs_numpy)\n",
    "\n",
    "xs_python: list[float] = []  # instantiate an empty list, we will build this \n",
    "ys_python: list[float] = []  # instantiate an empty list, we will build this\n",
    "\n",
    "\n",
    "# Define the number of points\n",
    "num_points = 1000\n",
    "\n",
    "# Define the start and end of the interval\n",
    "start = 0.0\n",
    "end = 6.0\n",
    "\n",
    "# Calculate the spacing between points\n",
    "step = (end - start) / (num_points - 1)\n",
    "\n",
    "# Generate the list of points\n",
    "for i in range(0, num_points): \n",
    "    xs_python.append(start + i * step)  # multiply each num 0 - 1000 (not including 1000) by step to get the x values (similar to x*dx) and add it to our list of x's\n",
    "\n",
    "for x in xs_python: # iterate through each elem of the the list \n",
    "    ys_python.append(more_complicated_function(x)) # give a y value for each x in our array and append that to the our empty y list\n",
    "    \n",
    "    # each y-value at an index couples corresponds the the y-value recieved when evaluating it in the x at the same index\n",
    "\n",
    "plt.plot(xs_python, ys_python, label='non-numpy', alpha=0.5, linestyle='dashed')\n",
    "plt.plot(xs_numpy, ys_numpy, label='numpy', alpha=0.5)\n",
    "plt.legend()\n",
    "plt.xlabel('x')\n",
    "plt.ylabel('f(x)')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b3405ec9-c96a-4ab7-b800-39870eaa2e7d",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
